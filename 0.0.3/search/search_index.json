{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"expiring_lru_cache expiring_lru_cache is a minimal drop-in replacement of functools.lru_cache . It allows the user to specify a time interval (in secs) after which the cache is invalidated and reset. Usage Here an example cached function whose cache will invalidate after 10 seconds. from expiring_lru_cache import lru_cache @lru_cache ( expires_after = 10 ) def my_plus_one_func ( x : int ) -> int : return x + 1 Here an example cached function whose cache will invalidate after 1 day. Note that the convenience variables MINUTES , HOURS and DAYS are available within the expiring_lru_cache namespace. from expiring_lru_cache import lru_cache , DAYS @lru_cache ( expires_after = 1 * DAYS ) def my_plus_one_func ( x : int ) -> int : return x + 1","title":"Home"},{"location":"#expiring_lru_cache","text":"expiring_lru_cache is a minimal drop-in replacement of functools.lru_cache . It allows the user to specify a time interval (in secs) after which the cache is invalidated and reset.","title":"expiring_lru_cache"},{"location":"#usage","text":"Here an example cached function whose cache will invalidate after 10 seconds. from expiring_lru_cache import lru_cache @lru_cache ( expires_after = 10 ) def my_plus_one_func ( x : int ) -> int : return x + 1 Here an example cached function whose cache will invalidate after 1 day. Note that the convenience variables MINUTES , HOURS and DAYS are available within the expiring_lru_cache namespace. from expiring_lru_cache import lru_cache , DAYS @lru_cache ( expires_after = 1 * DAYS ) def my_plus_one_func ( x : int ) -> int : return x + 1","title":"Usage"},{"location":"api/","text":"Core functionality. lru_cache ( expires_after = None , * args , ** kwargs ) LRU caching with expiration period. Acts as a drop-in replacement of functools.lru_cache . Arguments valid for functools.lru_cache can also be passed. Parameters: Name Type Description Default expires_after Optional [ int ] number of seconds after which to invalidate cache - None will never invalidate based on time. Convenience variables MINUTES , HOURS and DAYS are available (using lru_cache(expires_after=2 * DAYS) ) None args functools.lru_cache 's positional arguments required kwargs functools.lru_cache 's keyword arguments required Returns: Type Description Callable cached function Source code in expiring_lru_cache/__init__.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def lru_cache ( expires_after : Optional [ int ] = None , * args : Union [ int , bool ], ** kwargs : Union [ int , bool ] ) -> Callable : \"\"\" LRU caching with expiration period. Acts as a drop-in replacement of `functools.lru_cache`. Arguments valid for `functools.lru_cache` can also be passed. :param expires_after: number of seconds after which to invalidate cache - `None` will never invalidate based on time. Convenience variables `MINUTES`, `HOURS` and `DAYS` are available (using `lru_cache(expires_after=2 * DAYS)`) :param args: `functools.lru_cache`'s positional arguments :param kwargs: `functools.lru_cache`'s keyword arguments :return: cached function \"\"\" def decorate ( func : Callable ) -> Callable : cached_func = _init_cache ( func , expires_after , * args , ** kwargs ) @functools . wraps ( func ) def wrapper ( * args : Union [ int , bool ], ** kwargs : Union [ int , bool ]) -> Callable : nonlocal cached_func if _expired ( cached_func ): logging . debug ( \"Resetting cache\" ) cached_func = _init_cache ( func , expires_after , * args , ** kwargs ) return cached_func ( * args , ** kwargs ) return wrapper return decorate","title":"API"},{"location":"api/#expiring_lru_cache.lru_cache","text":"LRU caching with expiration period. Acts as a drop-in replacement of functools.lru_cache . Arguments valid for functools.lru_cache can also be passed. Parameters: Name Type Description Default expires_after Optional [ int ] number of seconds after which to invalidate cache - None will never invalidate based on time. Convenience variables MINUTES , HOURS and DAYS are available (using lru_cache(expires_after=2 * DAYS) ) None args functools.lru_cache 's positional arguments required kwargs functools.lru_cache 's keyword arguments required Returns: Type Description Callable cached function Source code in expiring_lru_cache/__init__.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def lru_cache ( expires_after : Optional [ int ] = None , * args : Union [ int , bool ], ** kwargs : Union [ int , bool ] ) -> Callable : \"\"\" LRU caching with expiration period. Acts as a drop-in replacement of `functools.lru_cache`. Arguments valid for `functools.lru_cache` can also be passed. :param expires_after: number of seconds after which to invalidate cache - `None` will never invalidate based on time. Convenience variables `MINUTES`, `HOURS` and `DAYS` are available (using `lru_cache(expires_after=2 * DAYS)`) :param args: `functools.lru_cache`'s positional arguments :param kwargs: `functools.lru_cache`'s keyword arguments :return: cached function \"\"\" def decorate ( func : Callable ) -> Callable : cached_func = _init_cache ( func , expires_after , * args , ** kwargs ) @functools . wraps ( func ) def wrapper ( * args : Union [ int , bool ], ** kwargs : Union [ int , bool ]) -> Callable : nonlocal cached_func if _expired ( cached_func ): logging . debug ( \"Resetting cache\" ) cached_func = _init_cache ( func , expires_after , * args , ** kwargs ) return cached_func ( * args , ** kwargs ) return wrapper return decorate","title":"lru_cache()"},{"location":"contrib/","text":"Contributing Thanks for contributing! Here's some useful information when requesting features/bugfixes. Setup We believe in well linted code. That means we also advocate for linting tools. Amongst those, we include: black isort flake8 (+ flake8-docstrings ) mypy (See .pre-commit-config.yaml for versions.) You may notice that these are not included in our pyproject.toml \ud83d\ude31. How's that, you ask? We use pre-commit to run these tools, which will create a separate environment for each tool (and avoid some dependency conflicts!). Though recommended, you don't need to use it, but we'll check that the code is compliant with these tools. We also package the code and set up environments using poetry . Putting it all together, we have pip install poetry==1.1.14 git clone git@github.com:datarootsio/expiring-lru-cache.git cd expiring-lru-cache poetry install poetry run pre-commit install Versioning We follow SemVer for package versions. You can check the version from expirining_lru_cache.__version__ . This is set dyanamically via CICD and kept in sync with git tags. Git tags Tagging happens in CICD. See the CICD file for more information. The bumping of tags also happens automatically with codacy/git-version@2.2.0 for commits in the main branch. If any commit contains breaking: , we'll have a major version bump. Including feature: will incur a minor version bump. The absence of both breaking: and feature: yields a patch bump. Including both breaking: and feature: will yield a major version bump. Documentation Documentation is handled by mkdocs , and can be created with markdown files in the docs/ directory. Documentation is hosted in GitHub pages and is also deployed via CICD .","title":"Contributing"},{"location":"contrib/#contributing","text":"Thanks for contributing! Here's some useful information when requesting features/bugfixes.","title":"Contributing"},{"location":"contrib/#setup","text":"We believe in well linted code. That means we also advocate for linting tools. Amongst those, we include: black isort flake8 (+ flake8-docstrings ) mypy (See .pre-commit-config.yaml for versions.) You may notice that these are not included in our pyproject.toml \ud83d\ude31. How's that, you ask? We use pre-commit to run these tools, which will create a separate environment for each tool (and avoid some dependency conflicts!). Though recommended, you don't need to use it, but we'll check that the code is compliant with these tools. We also package the code and set up environments using poetry . Putting it all together, we have pip install poetry==1.1.14 git clone git@github.com:datarootsio/expiring-lru-cache.git cd expiring-lru-cache poetry install poetry run pre-commit install","title":"Setup"},{"location":"contrib/#versioning","text":"We follow SemVer for package versions. You can check the version from expirining_lru_cache.__version__ . This is set dyanamically via CICD and kept in sync with git tags.","title":"Versioning"},{"location":"contrib/#git-tags","text":"Tagging happens in CICD. See the CICD file for more information. The bumping of tags also happens automatically with codacy/git-version@2.2.0 for commits in the main branch. If any commit contains breaking: , we'll have a major version bump. Including feature: will incur a minor version bump. The absence of both breaking: and feature: yields a patch bump. Including both breaking: and feature: will yield a major version bump.","title":"Git tags"},{"location":"contrib/#documentation","text":"Documentation is handled by mkdocs , and can be created with markdown files in the docs/ directory. Documentation is hosted in GitHub pages and is also deployed via CICD .","title":"Documentation"},{"location":"coverage/","text":"","title":"Coverage"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}